/**
 * ============================================================================
 * CustomerService Component
 * ============================================================================
 *
 * Main component for Customer Service Management System.
 * Provides dual-view interface for managing customer interactions:
 * - Chat View: Real-time customer chat management
 * - Ticketing View: Kanban-style ticket management
 *
 * Features:
 * - Dual agent tracking (AI + Human agents)
 * - Chat escalation workflow
 * - Real-time message handling
 * - Ticket creation and management
 * - Agent assignment and status tracking
 *
 * @module CustomerService
 */

// ============================================================================
// IMPORTS
// ============================================================================

// React core
import { useState, useEffect, useRef, useCallback } from "react";
import { useLocation } from "react-router-dom";

// Custom components
import { CustomerServiceSidebar, ChatFilters } from "./CustomerServiceSidebar";
import { ChatWindow } from "./ChatWindow";
import { AgentManagementModal } from "./AgentManagementModal";
import { TicketingKanban } from "./TicketingKanban";
import { NewChatModal } from "./NewChatModal";
import { WebSocketStatusIndicator } from "./WebSocketStatusIndicator";

// UI components
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";

// Icons
import {
  Users,
  MessageSquare,
  Ticket as TicketIcon,
  Loader2,
  Plus,
} from "lucide-react";

// Utilities and services
import { toast } from "sonner";
import { useAuth } from "@/contexts/AuthContext";
import { useRole } from "@/contexts/RoleContext";
import { useOrganization } from "@/contexts/OrganizationContext";
import { useWebSocket } from "@/contexts/WebSocketContext";
import type {
  WebSocketNotification,
  WebSocketNewMessage,
  WebSocketChatUpdate,
} from "@/contexts/WebSocketContext";
import * as crmAgentsService from "@/services/crmAgentsService";
import * as crmChatsService from "@/services/crmChatsService";
import {
  playNotificationSound,
  enableAudioNotifications,
} from "@/utils/audioNotification";
import { env } from "@/config/env";

// Types
import type { AgentFrontend, AgentStatus } from "@/services/crmAgentsService";
import type {
  Chat as APIChat,
  Message as APIMessage,
  Ticket as APITicket,
  Customer,
  CommunicationChannel,
  ChatObject,
} from "@/services/crmChatsService";

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * Message interface representing a single chat message
 *
 * @interface Message
 * @property {string} id - Unique identifier for the message
 * @property {string} sender - Type of sender (customer, agent, or ai)
 * @property {string} senderName - Display name of the sender
 * @property {string} content - Message content text
 * @property {string} timestamp - Formatted timestamp of when message was sent
 * @property {string} [ticketId] - Optional ticket ID if message is linked to a ticket
 */
interface Message {
  id: string;
  sender: "customer" | "agent" | "ai";
  senderName: string;
  content: string;
  timestamp: string;
  ticketId?: string;
}

/**
 * Ticket interface for customer support tickets
 *
 * @interface Ticket
 * @property {string} id - Unique identifier for the ticket
 * @property {string} ticketNumber - Human-readable ticket number (e.g., TKT-001)
 * @property {string} title - Brief title/summary of the ticket
 * @property {string} description - Detailed description of the issue
 * @property {string} category - Category classification of the ticket
 * @property {string} priority - Priority level: low, medium, high, or urgent
 * @property {string} status - Current status: open, in_progress, resolved, or closed
 * @property {string} createdAt - Timestamp when ticket was created
 * @property {string} updatedAt - Timestamp of last update
 * @property {string} [resolvedAt] - Timestamp when ticket was resolved
 * @property {string} [closedAt] - Timestamp when ticket was closed
 * @property {string} [assignedTo] - Name of agent assigned to ticket
 * @property {string[]} [tags] - Array of tags for categorization
 * @property {string[]} relatedMessages - Array of message IDs related to this ticket
 */
interface Ticket {
  id: string;
  ticketNumber: string;
  title: string;
  description: string;
  category: string;
  priority: "low" | "medium" | "high" | "urgent";
  status: "open" | "in_progress" | "resolved" | "closed";
  createdAt: string;
  updatedAt: string;
  resolvedAt?: string;
  closedAt?: string;
  assignedTo?: string;
  tags?: string[];
  relatedMessages: string[];
}

/**
 * Chat interface representing a customer conversation
 * Supports dual agent tracking (AI + Human agents) and escalation workflow
 *
 * @interface Chat
 * @property {string} id - Unique identifier for the chat
 * @property {string} customerName - Name of the customer
 * @property {string} lastMessage - Content of the most recent message
 * @property {string} timestamp - Formatted timestamp of last message
 * @property {number} unreadCount - Number of unread messages
 *
 * Legacy fields (backward compatibility):
 * @property {boolean} isAssigned - Whether chat is assigned to a human agent
 * @property {string} assignedTo - Name of assigned agent (human || ai || "-")
 *
 * Dual agent tracking:
 * @property {string} [aiAgentId] - ID of AI agent handling the chat
 * @property {string} [aiAgentName] - Name of AI agent
 * @property {string} [humanAgentId] - ID of human agent handling the chat
 * @property {string} [humanAgentName] - Name of human agent
 * @property {string} handledBy - Current handler: ai, human, or unassigned
 *
 * Escalation tracking:
 * @property {string} [escalatedAt] - Timestamp when chat was escalated
 * @property {string} [escalationReason] - Reason for escalation
 *
 * @property {string} channel - Communication channel (whatsapp, telegram, etc.)
 * @property {string} status - Chat status: open, pending, assigned, or resolved
 * @property {Message[]} messages - Array of messages in the chat
 * @property {string[]} [labels] - Optional labels for categorization
 * @property {string} createdDate - Date when chat was created
 * @property {string} [solvedBy] - Name of agent who solved the chat
 * @property {Ticket[]} [tickets] - Array of tickets related to this chat
 */
interface Chat {
  id: string;
  customerName: string;
  lastMessage: string;
  timestamp: string;
  unreadCount: number;
  // Legacy fields
  isAssigned: boolean;
  assignedTo: string;
  // Dual agent tracking
  aiAgentId?: string;
  aiAgentName?: string;
  humanAgentId?: string;
  humanAgentName?: string;
  humanId?: string; // NEW: User ID of the human agent (from API)
  handledBy: "ai" | "human" | "unassigned";
  // Escalation tracking
  escalatedAt?: string;
  escalationReason?: string;
  // Status and content
  channel: string;
  status: "open" | "pending" | "assigned" | "resolved";
  messages: Message[];
  labels?: string[];
  createdDate: string;
  solvedBy?: string;
  tickets?: Ticket[];
}

/**
 * Agent interface representing a customer service agent
 *
 * @interface Agent
 * @property {string} id - Unique identifier for the agent
 * @property {string} name - Full name of the agent
 * @property {string} email - Email address
 * @property {string} phone - Phone number
 * @property {string} status - Current status: active, inactive, or busy
 * @property {number} assignedChats - Number of currently assigned chats
 * @property {number} resolvedToday - Number of chats resolved today
 * @property {string} avgResponseTime - Average response time (formatted string)
 * @property {string} lastActive - Timestamp of last activity
 */
interface Agent {
  id: string;
  name: string;
  email: string;
  phone: string;
  status: "active" | "inactive" | "busy";
  assignedChats: number;
  resolvedToday: number;
  avgResponseTime: string;
  lastActive: string;
}

/**
 * WebSocket types now imported from WebSocketContext
 * See: @/contexts/WebSocketContext.tsx
 */

/**
 * Props for CustomerService component
 *
 * @interface CustomerServiceProps
 * @property {string} filterType - Current filter type: assigned or unassigned
 * @property {function} onFilterChange - Callback when filter changes
 */
interface CustomerServiceProps {
  filterType: "assigned" | "unassigned";
  onFilterChange: (filter: "assigned" | "unassigned") => void;
}

// ============================================================================
// MAIN COMPONENT
// ============================================================================

/**
 * CustomerService Component
 *
 * Main container component that orchestrates the customer service interface.
 * Manages state for chats, agents, tickets, and UI interactions.
 *
 * @param {CustomerServiceProps} props - Component props
 * @returns {JSX.Element} Rendered customer service interface
 */
export const CustomerService = ({
  filterType,
  onFilterChange,
}: CustomerServiceProps) => {
  // ==========================================================================
  // AUTH & USER
  // ==========================================================================

  /** Get current logged-in user and session */
  const { user, session } = useAuth();

  /** Get user roles for organization ID */
  const { userRoles } = useRole();

  /** Get current organization from context */
  const { currentOrganization } = useOrganization();

  /** Get location state for navigation (e.g., opening chat from notification) */
  const location = useLocation();

  // ==========================================================================
  // DERIVED VALUES (Primitives for stable dependencies)
  // ==========================================================================

  /** Extract primitive values to prevent object reference issues in useEffect */
  const organizationId = currentOrganization?.id;
  const accessToken = session?.access_token;

  // ==========================================================================
  // STATE MANAGEMENT
  // ==========================================================================

  // --------------------------------------------------------------------------
  // WebSocket State (from global WebSocketContext)
  // --------------------------------------------------------------------------
  const { wsStatus, reconnectAttempts, subscribeToMessages, resetUnreadCount } =
    useWebSocket();

  // --------------------------------------------------------------------------
  // UI State
  // --------------------------------------------------------------------------
  /** Currently selected chat ID */
  const [activeChat, setActiveChat] = useState<string | null>(null);

  /** Filters for chat list sidebar */
  const [filters, setFilters] = useState<ChatFilters>({
    readStatus: "all",
    agent: "all",
    status: "all",
    channel: "all",
  });

  /** Agent management modal visibility */
  const [agentModalOpen, setAgentModalOpen] = useState(false);

  /** New chat creation modal visibility */
  const [newChatModalOpen, setNewChatModalOpen] = useState(false);

  /** Current view mode: chat or ticketing */
  const [viewMode, setViewMode] = useState<"chat" | "ticketing">("chat");

  // --------------------------------------------------------------------------
  // Agent State
  // --------------------------------------------------------------------------
  /** List of all available agents */
  const [agents, setAgents] = useState<Agent[]>([]);

  /** Loading state for agents fetch */
  const [agentsLoading, setAgentsLoading] = useState(true);

  // --------------------------------------------------------------------------
  // Chat & Message State
  // --------------------------------------------------------------------------
  /** List of all chats (filtered by assigned/unassigned) */
  const [chats, setChats] = useState<Chat[]>([]);

  /** Loading state for chats fetch */
  const [chatsLoading, setChatsLoading] = useState(true);

  /** Map of customer IDs to customer objects for quick lookup */
  const [customersMap, setCustomersMap] = useState<Map<string, Customer>>(
    new Map()
  );

  /** Messages for currently active chat */
  const [currentChatMessages, setCurrentChatMessages] = useState<Message[]>([]);

  /** Loading state for messages fetch */
  const [messagesLoading, setMessagesLoading] = useState(false);

  // ==========================================================================
  // API INTEGRATION - DATA FETCHING HOOKS
  // ==========================================================================

  /**
   * Effect: Fetch chats when filter type or filters change
   *
   * Fetches chats from API based on assigned/unassigned filter and sidebar filters.
   * - assigned: Shows human-handled chats
   * - unassigned: Shows AI-handled and unassigned chats
   *
   * API Parameters (server-side filtering):
   * - handled_by: Based on filterType (assigned/unassigned)
   * - status_filter: From filters.status (if not "all")
   * - channel: From filters.channel (if not "all")
   *
   * Client-side filtering (in CustomerServiceSidebar):
   * - agent: Kept client-side due to name-to-ID mapping complexity
   * - readStatus: Computed value from unreadCount
   * - searchQuery: Customer name search
   *
   * Dependencies: [filterType, filters]
   */
  useEffect(() => {
    const fetchChats = async () => {
      try {
        setChatsLoading(true);

        // Build API parameters from filterType and sidebar filters
        const apiChats = await crmChatsService.getChats({
          // Filter by assigned/unassigned
          handled_by: filterType === "assigned" ? "human" : undefined,

          // Apply sidebar filters to API (server-side filtering)
          status_filter: filters.status !== "all" ? filters.status : undefined,
          channel:
            filters.channel !== "all" ? (filters.channel as any) : undefined,
          // Note: agent filter is kept client-side because we need to map agent name to ID
          // which requires additional complexity. Agent list is typically small, so client-side
          // filtering is acceptable for now.
        });

        // Transform API chats to frontend format
        const transformedChats: Chat[] = await Promise.all(
          apiChats?.chats?.map(async (apiChat) => {
            // Fetch customer details if not populated
            let customer: Customer | undefined;

            // Fetch agent details if assigned
            let assignedAgent: Agent | undefined;

            return {
              id: apiChat.id,
              customerName: apiChat.customer_name || "Unknown Customer",
              lastMessage: apiChat.last_message?.content || "",
              timestamp: new Date(apiChat.last_message_at).toLocaleTimeString(
                [],
                {
                  hour: "2-digit",
                  minute: "2-digit",
                }
              ),
              unreadCount: apiChat.unread_count || 0,

              // Legacy fields (backward compatibility)
              isAssigned: apiChat.handled_by === "human",
              assignedTo:
                (apiChat.handled_by === "human"
                  ? apiChat.human_agent_name
                  : apiChat.ai_agent_name) || "-",

              // NEW: Dual agent tracking
              aiAgentId: apiChat.ai_agent_id || undefined,
              aiAgentName: apiChat.ai_agent_name || undefined,
              humanAgentId: apiChat.human_agent_id || undefined,
              humanAgentName: apiChat.human_agent_name || undefined,
              humanId: apiChat.human_id || undefined, // NEW: User ID of human agent
              handledBy: apiChat.handled_by,

              // NEW: Escalation tracking
              escalatedAt: apiChat.escalated_at || undefined,
              escalationReason: apiChat.escalation_reason || undefined,

              // NEW: Channel and status
              channel: apiChat.channel || "-",
              status: apiChat.status as
                | "open"
                | "pending"
                | "assigned"
                | "resolved",
              messages: [], // Will be loaded when chat is selected
              labels: [], // TODO: Add labels support in API
              createdDate: new Date(apiChat.created_at).toLocaleDateString(),
              solvedBy: apiChat.resolved_by_agent_id
                ? assignedAgent?.name
                : undefined,
              tickets: [], // Will be loaded separately
            };
          })
        );

        setChats(transformedChats);
      } catch (error) {
        console.error("Error fetching chats:", error);
        // Only show error toast if it's not just empty data
        if (error && typeof error === "object" && "response" in error) {
          toast.error("Gagal memuat data chats");
        }
      } finally {
        setChatsLoading(false);
      }
    };

    fetchChats();
  }, [filterType, filters]);

  /**
   * Fetch chat details (messages and tickets) when a chat is selected
   *
   * @effect
   * @listens activeChat - Triggered when active chat changes
   *
   * API Integration:
   * - Fetches messages from /crm/chats/:chatId/messages
   * - Uses sender_name from API response directly (no complex lookups)
   * - Tickets feature currently in development (commented out)
   *
   * Data Transformation:
   * - Maps API message fields to frontend Message interface
   * - Formats timestamp to HH:MM format
   * - Preserves ticket_id for future ticket linking
   *
   * State Updates:
   * - Updates currentChatMessages for active chat display
   * - Updates messages array in chats state for persistence
   */
  useEffect(() => {
    if (!activeChat) {
      setCurrentChatMessages([]);
      return;
    }

    const fetchChatDetails = async () => {
      try {
        setMessagesLoading(true);

        // Fetch messages from API
        const messagesResponse = await crmChatsService.getChatMessages(
          activeChat
        );

        // Transform messages to frontend format
        // Uses sender_name directly from API response
        const transformedMessages: Message[] = messagesResponse.messages.map(
          (apiMsg) => ({
            id: apiMsg.id,
            sender: apiMsg.sender_type as "customer" | "agent" | "ai",
            senderName: apiMsg.sender_name || "-",
            content: apiMsg.content,
            timestamp: new Date(apiMsg.created_at).toLocaleTimeString([], {
              hour: "2-digit",
              minute: "2-digit",
            }),
            ticketId: apiMsg.ticket_id || undefined,
          })
        );

        setCurrentChatMessages(transformedMessages);

        // Update chat messages in state for persistence
        setChats((prevChats) =>
          prevChats.map((chat) =>
            chat.id === activeChat
              ? { ...chat, messages: transformedMessages }
              : chat
          )
        );

        // ====================================================================
        // TICKETS SECTION - Currently in Development
        // ====================================================================
        // TODO: Uncomment when tickets API is fully implemented
        //
        // // Fetch tickets for this chat
        // const apiTickets = await crmChatsService.getTickets({
        //   // Filter tickets by chat_id - assuming API supports this
        // });
        //
        // // Filter tickets for current chat
        // const chatTickets = apiTickets.filter(t => t.chat_id === activeChat);
        //
        // // Transform tickets
        // const transformedTickets: Ticket[] = chatTickets.map((apiTicket) => {
        //   const chat = chats.find(c => c.id === activeChat);
        //   return {
        //     id: apiTicket.id,
        //     ticketNumber: apiTicket.ticket_number,
        //     title: apiTicket.title,
        //     description: apiTicket.description || '',
        //     category: apiTicket.category || 'Uncategorized',
        //     priority: apiTicket.priority as "low" | "medium" | "high" | "urgent",
        //     status: apiTicket.status as "open" | "in_progress" | "resolved" | "closed",
        //     createdAt: new Date(apiTicket.created_at).toLocaleString(),
        //     updatedAt: new Date(apiTicket.updated_at).toLocaleString(),
        //     resolvedAt: apiTicket.resolved_at ? new Date(apiTicket.resolved_at).toLocaleString() : undefined,
        //     closedAt: apiTicket.closed_at ? new Date(apiTicket.closed_at).toLocaleString() : undefined,
        //     assignedTo: chat?.assignedTo,
        //     tags: apiTicket.tags,
        //     relatedMessages: transformedMessages.filter(m => m.ticketId === apiTicket.id).map(m => m.id),
        //   };
        // });
        //
        // // Update tickets in state
        // setChats(prevChats =>
        //   prevChats.map(chat =>
        //     chat.id === activeChat
        //       ? { ...chat, tickets: transformedTickets }
        //       : chat
        //   )
        // );
      } catch (error) {
        console.error("Error fetching chat details:", error);
        toast.error("Gagal memuat detail chat");
      } finally {
        setMessagesLoading(false);
      }
    };

    fetchChatDetails();
  }, [activeChat]);

  // Fetch agents on component mount
  useEffect(() => {
    const fetchAgents = async () => {
      try {
        setAgentsLoading(true);
        const fetchedAgents = await crmAgentsService.getAgents();
        setAgents(fetchedAgents);
      } catch (error) {
        console.error("Error fetching agents:", error);
        toast.error("Gagal memuat data agents");
      } finally {
        setAgentsLoading(false);
      }
    };

    fetchAgents();
  }, []);

  // ==========================================================================
  // WEBSOCKET HANDLERS
  // ==========================================================================

  /**
   * Handle new message notification from WebSocket
   * Updates chat list and appends message if chat is active
   * Memoized to prevent unnecessary WebSocket reconnections
   */
  const handleNewMessageNotification = useCallback(
    (notification: WebSocketNewMessage) => {
      const { data } = notification;
      const { chat_id, message_id, customer_name, message_content } = data;

      // Idempotency check: prevent duplicate message processing
      // if (processedMessageIdsRef.current.has(message_id)) {
      //   console.log('â­ï¸ Message already processed, skipping:', message_id);
      //   return;
      // }
      // processedMessageIdsRef.current.add(message_id);

      // Update chats list with new message
      setChats((prevChats) => {
        const chatIndex = prevChats.findIndex((chat) => chat.id === chat_id);

        if (chatIndex === -1) {
          // New chat - will be handled by API polling
          console.log("New chat detected, will be loaded by next API fetch");
          return prevChats;
        }

        const updatedChats = [...prevChats];
        const chat = updatedChats[chatIndex];

        // Update chat with new message info
        updatedChats[chatIndex] = {
          ...chat,
          lastMessage: message_content,
          timestamp: new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }),
          // Increment unread count only if chat is not active
          unreadCount:
            chat.id === activeChat ? chat.unreadCount : chat.unreadCount + 1,
        };

        // Move chat to top of list
        const [updatedChat] = updatedChats.splice(chatIndex, 1);
        updatedChats.unshift(updatedChat);

        return updatedChats;
      });

      // If this is the active chat, append message to conversation
      if (chat_id === activeChat) {
        const transformedMessage: Message = {
          id: message_id,
          sender: data.handled_by === "ai" ? "ai" : "customer",
          senderName: customer_name,
          content: message_content,
          timestamp: new Date().toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }),
        };

        setCurrentChatMessages((prev) => {
          // Check if message already exists (idempotency at UI level)
          if (prev.some((msg) => msg.id === message_id)) {
            return prev;
          }
          return [...prev, transformedMessage];
        });
      } else {
        // Show notification for background chats
        // Note: Using functional update to get chat from prevChats instead of external chats variable
        setChats((prevChats) => {
          const chat = prevChats.find((c) => c.id === chat_id);
          if (chat) {
            toast.info(`New message from ${customer_name}`, {
              action: {
                label: "View",
                onClick: () => setActiveChat(chat_id),
              },
              duration: 5000,
            });
          }
          return prevChats; // No state change, just using for side effect
        });

        // Play notification sound
        playNotificationSound("message", 0.5);
      }
    },
    [activeChat]
  ); // activeChat is the only external dependency

  /**
   * Handle chat update notification (assignment, escalation, status change)
   * Memoized to prevent unnecessary WebSocket reconnections
   */
  const handleChatUpdateNotification = useCallback(
    (notification: WebSocketChatUpdate) => {
      const { data, update_type } = notification;
      const { chat_id } = data;

      console.log("ðŸ”„ Chat update received:", update_type, data);

      // Update chat in list
      setChats((prevChats) =>
        prevChats.map((chat) => {
          if (chat.id !== chat_id) return chat;

          const updatedChat = { ...chat };

          // Handle different update types
          if (update_type === "assigned" && data.to_agent) {
            updatedChat.humanAgentId = data.to_agent;
            updatedChat.handledBy = "human";
            updatedChat.isAssigned = true;
          }

          if (update_type === "escalated") {
            updatedChat.humanAgentId = data.to_agent;
            updatedChat.handledBy = "human";
            updatedChat.escalatedAt = new Date().toISOString();
            updatedChat.escalationReason = data.reason;
            toast.info(
              `Chat escalated: ${data.reason || "No reason provided"}`
            );
          }

          if (update_type === "status_changed" && data.status) {
            updatedChat.status = data.status;
            if (data.status === "resolved") {
              toast.success("Chat resolved");
            }
          }

          return updatedChat;
        })
      );

      // If this is the active chat, show notification
      if (chat_id === activeChat) {
        if (update_type === "assigned") {
          toast.info("Chat assignment updated");
        }
      }
    },
    [activeChat]
  ); // activeChat is the only external dependency

  /**
   * Handle incoming WebSocket messages
   * Routes messages to appropriate handlers based on type
   * Memoized to prevent unnecessary WebSocket reconnections
   */
  const handleWebSocketMessage = useCallback(
    (notification: WebSocketNotification) => {
      console.log(
        "ðŸ“© WebSocket notification received:",
        notification.type,
        notification
      );

      switch (notification.type) {
        case "connection_established":
          console.log(
            "âœ… WebSocket connection established:",
            notification.message
          );
          // Toast removed - WebSocketStatusIndicator already shows connection status
          // Showing toast here causes re-render loop that triggers cleanup
          break;

        case "new_message":
          handleNewMessageNotification(notification);
          break;

        case "chat_update":
          handleChatUpdateNotification(notification);
          break;

        default:
          console.log("ðŸ“© Unknown notification type:", notification);
      }
    },
    [handleNewMessageNotification, handleChatUpdateNotification]
  ); // Depend on memoized handlers

  // ==========================================================================
  // WEBSOCKET CONNECTION
  // ==========================================================================

  /**
   * Subscribe to WebSocket messages from global WebSocketContext
   * WebSocket connection is managed globally, this component only handles CRM-specific logic
   */
  useEffect(() => {
    console.log("ðŸ“¡ CustomerService: Subscribing to WebSocket messages");

    const unsubscribe = subscribeToMessages((notification) => {
      // Only handle messages when on CRM page (this component is mounted)
      handleWebSocketMessage(notification);
    });

    // Cleanup subscription when component unmounts
    return () => {
      console.log("ðŸ“¡ CustomerService: Unsubscribing from WebSocket messages");
      unsubscribe();
    };
  }, [subscribeToMessages, handleWebSocketMessage]);

  /**
   * Handle navigation state - open chat from notification click
   */
  useEffect(() => {
    const state = location.state as { openChatId?: string } | null;
    if (state?.openChatId) {
      console.log("ðŸ“‚ Opening chat from navigation state:", state.openChatId);
      setActiveChat(state.openChatId);

      // Clear unread count for this chat
      resetUnreadCount();

      // Clear navigation state to prevent reopening on future renders
      window.history.replaceState({}, document.title);
    }
  }, [location.state, resetUnreadCount]);

  // Reset unread count when chat is opened
  useEffect(() => {
    if (activeChat) {
      setChats((prevChats) =>
        prevChats.map((chat) =>
          chat.id === activeChat ? { ...chat, unreadCount: 0 } : chat
        )
      );

      // Decrease global unread count (assuming user is now viewing this chat)
      // Note: GlobalChatNotifications will increment it, CustomerService decrements when viewing
      resetUnreadCount();
    }
  }, [activeChat, resetUnreadCount]);

  const selectedChat = chats.find((chat) => chat.id === activeChat);

  const handleSendMessage = async (message: string) => {
    if (!activeChat) return;

    try {
      const selectedChat = chats.find((c) => c.id === activeChat);
      if (!selectedChat) return;

      // Validate: Only assigned agent can send messages
      if (!user?.id) {
        toast.error("Anda harus login untuk mengirim pesan");
        return;
      }

      if (selectedChat.humanId && selectedChat.humanId !== user.id) {
        toast.error(
          "Hanya agent yang ditugaskan yang dapat mengirim pesan ke chat ini"
        );
        return;
      }

      // Build metadata with agent info, chat context, timestamp, and source
      const metadata = {
        // Agent info
        agent_name: user.user_metadata?.name || user.email || "Unknown Agent",
        agent_email: user.email,

        // Chat context
        handled_by: selectedChat.handledBy,
        chat_status: selectedChat.status,

        // Timestamp & source
        sent_at: new Date().toISOString(),
        source: "web_ui",
        user_agent: navigator.userAgent,
      };

      // Send message via API with complete payload
      const sentMessage = await crmChatsService.sendMessage(
        activeChat,
        message,
        "agent", // sender_type - always 'agent' for human agents
        user.id, // sender_id - agent UUID
        undefined, // ticket_id - not implemented yet
        metadata // metadata - comprehensive context
      );

      // Transform to frontend format
      const transformedMessage: Message = {
        id: sentMessage.id,
        sender: "agent",
        senderName: selectedChat.isAssigned
          ? selectedChat.assignedTo!
          : "AI Assistant",
        content: sentMessage.content,
        timestamp: new Date(sentMessage.created_at).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
        ticketId: sentMessage.ticket_id || undefined,
      };

      // Update local state
      setChats((prevChats) =>
        prevChats.map((chat) =>
          chat.id === activeChat
            ? {
                ...chat,
                messages: [...chat.messages, transformedMessage],
                lastMessage: message,
                timestamp: new Date().toLocaleTimeString([], {
                  hour: "2-digit",
                  minute: "2-digit",
                }),
              }
            : chat
        )
      );

      setCurrentChatMessages((prev) => [...prev, transformedMessage]);
    } catch (error) {
      console.error("Error sending message:", error);
      toast.error("Gagal mengirim pesan");
    }
  };

  /**
   * Handle assigning chat to current user (Assign to Me)
   * Uses assigned_to_me API parameter instead of requiring agent ID
   */
  const handleAssignToAgent = async () => {
    if (!activeChat) return;

    try {
      // Assign chat to current user using assigned_to_me parameter
      const updatedChat = await crmChatsService.assignChat(
        activeChat,
        null, // No agent ID needed for "assign to me"
        {
          assignToMe: true,
          reason: "Taking this conversation",
        }
      );

      // Update local state with API response
      setChats((prevChats) =>
        prevChats.map((chat) =>
          chat.id === activeChat
            ? {
                ...chat,
                // Update with actual values from API response
                isAssigned: updatedChat.handled_by === "human",
                assignedTo:
                  updatedChat.human_agent_name ||
                  updatedChat.ai_agent_name ||
                  "You",
                humanAgentId: updatedChat.human_agent_id,
                humanAgentName: updatedChat.human_agent_name,
                handledBy: updatedChat.handled_by,
                status: updatedChat.status as
                  | "open"
                  | "pending"
                  | "assigned"
                  | "resolved",
              }
            : chat
        )
      );

      toast.success("Chat berhasil diassign ke Anda");
    } catch (error) {
      console.error("Error assigning chat:", error);
      toast.error("Gagal assign chat");
    }
  };

  const handleMarkResolved = async () => {
    if (!activeChat) return;

    try {
      // Resolve chat via API
      await crmChatsService.resolveChat(activeChat);

      // Update local state
      setChats((prevChats) =>
        prevChats.map((chat) =>
          chat.id === activeChat
            ? {
                ...chat,
                status: "resolved",
              }
            : chat
        )
      );

      toast.success("Chat berhasil diresolve");
    } catch (error) {
      console.error("Error resolving chat:", error);
      toast.error("Gagal resolve chat");
    }
  };

  // NEW: Handle escalate chat to human agent
  const handleEscalateChat = async (humanAgentId: string, reason?: string) => {
    if (!activeChat) return;

    try {
      // Escalate chat via API
      const updatedChat = await crmChatsService.escalateChat(activeChat, {
        human_agent_id: humanAgentId,
        reason,
      });

      // Update local state with new dual agent data
      setChats((prevChats) =>
        prevChats.map((chat) =>
          chat.id === activeChat
            ? {
                ...chat,
                // Update dual agent fields
                humanAgentId: updatedChat.human_agent_id || undefined,
                humanAgentName: updatedChat.human_agent_name || undefined,
                handledBy: updatedChat.handled_by,
                escalatedAt: updatedChat.escalated_at || undefined,
                escalationReason: updatedChat.escalation_reason || undefined,
                // Update legacy fields for backward compatibility
                isAssigned: true,
                assignedTo: updatedChat.human_agent_name || undefined,
                status: "assigned",
              }
            : chat
        )
      );

      toast.success("Chat berhasil di-escalate ke human agent");
    } catch (error: any) {
      console.error("Error escalating chat:", error);
      const errorMessage =
        error?.response?.data?.detail || "Gagal escalate chat";
      toast.error(errorMessage);
    }
  };

  const handleAddAgent = async (
    agentData: Omit<
      Agent,
      | "id"
      | "assignedChats"
      | "resolvedToday"
      | "avgResponseTime"
      | "lastActive"
    >
  ) => {
    try {
      const newAgent = await crmAgentsService.createAgent(agentData);
      setAgents((prev) => [...prev, newAgent]);
      toast.success("Agent berhasil ditambahkan");
    } catch (error) {
      console.error("Error adding agent:", error);
      toast.error("Gagal menambahkan agent. Silakan coba lagi.");
    }
  };

  const handleUpdateAgentStatus = async (
    agentId: string,
    status: "active" | "inactive" | "busy"
  ) => {
    try {
      const updatedAgent = await crmAgentsService.updateAgentStatus(
        agentId,
        status as AgentStatus
      );
      setAgents((prev) =>
        prev.map((agent) => (agent.id === agentId ? updatedAgent : agent))
      );
      toast.success("Status agent berhasil diupdate");
    } catch (error) {
      console.error("Error updating agent status:", error);
      toast.error("Gagal mengupdate status agent. Silakan coba lagi.");
    }
  };

  const handleSaveAgentSettings = async (agentId: string, settings: any) => {
    try {
      await crmAgentsService.updateAgentSettings(agentId, settings);
      // Optimistic update for UI
      setAgents((prev) =>
        prev.map((agent) =>
          agent.id === agentId ? { ...agent, settings } : agent
        )
      );
      toast.success("Settings agent berhasil disimpan");
    } catch (error) {
      console.error("Error saving agent settings:", error);
      toast.error("Gagal menyimpan settings agent. Silakan coba lagi.");
    }
  };

  const handleCreateTicket = async (
    ticket: Omit<
      Ticket,
      "id" | "ticketNumber" | "createdAt" | "updatedAt" | "relatedMessages"
    >
  ) => {
    if (!activeChat) return;

    try {
      // Create ticket via API
      const createdTicket = await crmChatsService.createTicket({
        chat_id: activeChat,
        title: ticket.title,
        description: ticket.description,
        category: ticket.category,
        priority: ticket.priority as crmChatsService.TicketPriority,
        tags: ticket.tags,
      });

      // Transform to frontend format
      const newTicket: Ticket = {
        id: createdTicket.id,
        ticketNumber: createdTicket.ticket_number,
        title: createdTicket.title,
        description: createdTicket.description || "",
        category: createdTicket.category || "Uncategorized",
        priority: createdTicket.priority as
          | "low"
          | "medium"
          | "high"
          | "urgent",
        status: createdTicket.status as
          | "open"
          | "in_progress"
          | "resolved"
          | "closed",
        createdAt: new Date(createdTicket.created_at).toLocaleString(),
        updatedAt: new Date(createdTicket.updated_at).toLocaleString(),
        assignedTo: ticket.assignedTo,
        tags: createdTicket.tags,
        relatedMessages: [],
      };

      // Update local state
      setChats((prevChats) =>
        prevChats.map((chat) =>
          chat.id === activeChat
            ? {
                ...chat,
                tickets: [...(chat.tickets || []), newTicket],
              }
            : chat
        )
      );

      toast.success("Ticket berhasil dibuat");
    } catch (error) {
      console.error("Error creating ticket:", error);
      toast.error("Gagal membuat ticket");
    }
  };

  const handleCreateChat = async (data: {
    channel: CommunicationChannel;
    contact: string;
    customerName: string;
    initialMessage: string;
    assignedAgentId?: string;
  }) => {
    try {
      // Create chat via API
      const createdChat = await crmChatsService.createChat({
        customer_name: data.customerName,
        contact: data.contact,
        channel: data.channel,
        initial_message: data.initialMessage,
      });

      // If agent is assigned, assign the chat to specific agent
      if (data.assignedAgentId) {
        try {
          await crmChatsService.assignChat(
            createdChat.id,
            data.assignedAgentId,
            { assignToMe: false } // Assign to specific agent, not current user
          );
        } catch (error) {
          console.error("Failed to assign chat to agent:", error);
          // Continue even if assignment fails
        }
      }

      // Find assigned agent details
      const assignedAgent = data.assignedAgentId
        ? agents.find((a) => a.id === data.assignedAgentId)
        : undefined;

      // Transform to frontend format
      const newChat: Chat = {
        id: createdChat.id,
        customerName: data.customerName,
        lastMessage: data.initialMessage,
        timestamp: new Date(createdChat.created_at).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
        unreadCount: 0,
        isAssigned: !!data.assignedAgentId,
        assignedTo: assignedAgent?.name || "-",
        handledBy: data.assignedAgentId ? "human" : "unassigned",
        channel: data.channel || "-",
        status: data.assignedAgentId
          ? "assigned"
          : (createdChat.status as
              | "open"
              | "pending"
              | "assigned"
              | "resolved"),
        messages: [],
        labels: [],
        createdDate: new Date(createdChat.created_at).toLocaleDateString(),
        tickets: [],
      };

      // Add to chats list
      setChats((prevChats) => [newChat, ...prevChats]);

      // Auto-select the new chat
      setActiveChat(createdChat.id);

      toast.success("Chat baru berhasil dibuat!");
    } catch (error: any) {
      console.error("Error creating chat:", error);
      toast.error(error?.message || "Gagal membuat chat baru");
      throw error; // Re-throw to let modal handle it
    }
  };

  const handleUpdateTicket = async (
    ticketId: string,
    updates: Partial<Ticket>
  ) => {
    try {
      // Update ticket via API
      const apiUpdates: any = {};
      if (updates.title) apiUpdates.title = updates.title;
      if (updates.description) apiUpdates.description = updates.description;
      if (updates.category) apiUpdates.category = updates.category;
      if (updates.priority) apiUpdates.priority = updates.priority;
      if (updates.status) apiUpdates.status = updates.status;
      if (updates.assignedTo) {
        // Find agent ID by name
        const agent = agents.find((a) => a.name === updates.assignedTo);
        if (agent) apiUpdates.assigned_agent_id = agent.id;
      }
      if (updates.tags) apiUpdates.tags = updates.tags;

      const updatedTicket = await crmChatsService.updateTicket(
        ticketId,
        apiUpdates
      );

      // Update local state
      setChats((prevChats) =>
        prevChats.map((chat) => ({
          ...chat,
          tickets: (chat.tickets || []).map((ticket) =>
            ticket.id === ticketId
              ? {
                  ...ticket,
                  ...updates,
                  updatedAt: new Date(
                    updatedTicket.updated_at
                  ).toLocaleString(),
                  ...(updates.status === "resolved" && !ticket.resolvedAt
                    ? { resolvedAt: new Date().toLocaleString() }
                    : {}),
                  ...(updates.status === "closed" && !ticket.closedAt
                    ? { closedAt: new Date().toLocaleString() }
                    : {}),
                }
              : ticket
          ),
        }))
      );

      toast.success("Ticket berhasil diupdate");
    } catch (error) {
      console.error("Error updating ticket:", error);
      toast.error("Gagal update ticket");
    }
  };

  // Get all tickets from all chats
  const allTickets = chats.flatMap((chat) =>
    (chat.tickets || []).map((ticket) => ({
      ...ticket,
      customerName: chat.customerName,
      chatId: chat.id,
    }))
  );

  return (
    <div
      className="flex flex-col h-[calc(100vh-10rem)] border rounded-lg overflow-hidden"
      onClick={enableAudioNotifications}
    >
      {/* View Mode Selector */}
      <div className="border-b bg-card p-2">
        <Tabs
          value={viewMode}
          onValueChange={(value) => setViewMode(value as "chat" | "ticketing")}
        >
          <TabsList className="grid w-full max-w-md mx-auto grid-cols-2 h-9 p-1">
            <TabsTrigger
              value="chat"
              className="flex items-center justify-center gap-1.5 text-xs data-[state=active]:bg-background"
            >
              <MessageSquare className="h-3.5 w-3.5" />
              Chat View
            </TabsTrigger>
            <TabsTrigger
              value="ticketing"
              className="flex items-center justify-center gap-1.5 text-xs data-[state=active]:bg-background"
            >
              <TicketIcon className="h-3.5 w-3.5" />
              Ticketing View
            </TabsTrigger>
          </TabsList>
        </Tabs>
      </div>

      {/* Content Area */}
      <div className="flex flex-1 overflow-hidden">
        {viewMode === "chat" ? (
          <>
            {/* Sidebar for Chat View */}
            <div className="w-64 flex flex-col border-r">
              {/* Header - Fixed */}
              <div className="p-2 border-b bg-card space-y-2 flex-shrink-0">
                {/* WebSocket Status Indicator */}
                <div className="flex justify-center">
                  <WebSocketStatusIndicator
                    status={wsStatus}
                    reconnectAttempts={reconnectAttempts}
                  />
                </div>

                <Tabs
                  value={filterType}
                  onValueChange={(value) =>
                    onFilterChange(value as "assigned" | "unassigned")
                  }
                >
                  <TabsList className="grid w-full grid-cols-2 h-9 p-1">
                    <TabsTrigger
                      value="unassigned"
                      className="text-xs data-[state=active]:bg-background"
                    >
                      Unassigned
                    </TabsTrigger>
                    <TabsTrigger
                      value="assigned"
                      className="text-xs data-[state=active]:bg-background"
                    >
                      Assigned
                    </TabsTrigger>
                  </TabsList>
                </Tabs>

                {/* Agent Management Button */}
                <Button
                  variant="outline"
                  className="w-full h-8 text-xs"
                  size="sm"
                  onClick={() => setAgentModalOpen(true)}
                >
                  <Users className="h-3.5 w-3.5 mr-1.5" />
                  Manage Agents
                </Button>
              </div>

              {/* Chat List - Scrollable */}
              <div className="flex-1 min-h-0">
                <CustomerServiceSidebar
                  chats={chats}
                  activeChat={activeChat}
                  onChatSelect={setActiveChat}
                  filterType={filterType}
                  filters={filters}
                  onFiltersChange={setFilters}
                  isLoading={chatsLoading}
                />
              </div>

              {/* New Chat Button - Fixed at Bottom */}
              <div className="p-3 border-t bg-card flex-shrink-0">
                <Button
                  className="w-full h-9 text-sm shadow-sm"
                  size="sm"
                  onClick={() => setNewChatModalOpen(true)}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  New Chat
                </Button>
              </div>
            </div>

            {/* Chat Window */}
            <ChatWindow
              chatId={activeChat}
              customerName={selectedChat?.customerName || ""}
              status={selectedChat?.status || "open"}
              isAssigned={selectedChat?.isAssigned || false}
              assignedTo={selectedChat?.assignedTo}
              isOwnChat={selectedChat?.humanId === user?.id}
              // NEW: Dual agent tracking props
              aiAgentName={selectedChat?.aiAgentName}
              humanAgentName={selectedChat?.humanAgentName}
              handledBy={selectedChat?.handledBy || "unassigned"}
              escalatedAt={selectedChat?.escalatedAt}
              escalationReason={selectedChat?.escalationReason}
              messages={selectedChat?.messages || []}
              tickets={selectedChat?.tickets || []}
              isLoading={messagesLoading}
              agents={agents}
              onSendMessage={handleSendMessage}
              onAssignToAgent={handleAssignToAgent}
              onMarkResolved={handleMarkResolved}
              onEscalateToHuman={handleEscalateChat}
              onCreateTicket={handleCreateTicket}
              onUpdateTicket={handleUpdateTicket}
            />
          </>
        ) : (
          <TicketingKanban
            tickets={allTickets}
            agents={agents}
            onUpdateTicket={handleUpdateTicket}
          />
        )}
      </div>

      {/* Agent Management Modal */}
      <AgentManagementModal
        open={agentModalOpen}
        onClose={() => setAgentModalOpen(false)}
        agents={agents}
        onAddAgent={handleAddAgent}
        onUpdateAgentStatus={handleUpdateAgentStatus}
        onSaveAgentSettings={handleSaveAgentSettings}
      />

      {/* New Chat Modal */}
      <NewChatModal
        open={newChatModalOpen}
        onClose={() => setNewChatModalOpen(false)}
        agents={agents}
        onCreateChat={handleCreateChat}
      />
    </div>
  );
};
